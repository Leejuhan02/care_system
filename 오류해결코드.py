# -*- coding: utf-8 -*-
"""오류해결코드.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dZ6sL3F_-uG5i8-AW7Mws_85SBMol2oo
"""

#1. src/hardware.py (스피커 충돌 방지 및 오류 해결)
# src/hardware.py
import threading
import time
import numpy as np
import sounddevice as sd
from multiprocessing import Queue
from gpiozero import Button
import config

# --- ButtonReader는 이전과 동일 (생략 가능, 확인용) ---
class ButtonReader:
    def __init__(self, event_queue: Queue):
        self.queue = event_queue
        self.pin = config.BUTTON_PIN
        self.btn = None
        try:
            self.btn = Button(self.pin, pull_up=True, bounce_time=0.2)
            self.btn.when_pressed = self._on_press
            print(f"[Hardware] 버튼 초기화 완료 (Pin {self.pin})")
        except Exception as e:
            print(f"[Hardware] 버튼 오류: {e}")

    def start(self):
        pass  # gpiozero는 별도 start 불필요

    def _on_press(self):
        print("[Hardware] 버튼 눌림!")
        self.queue.put("BUTTON_PRESSED")

    def cleanup(self):
        if self.btn: self.btn.close()

# --- [중요] 스피커 오류 수정 버전 ---
class Speaker:
    def __init__(self):
        self.is_playing = False
        self.stop_signal = False

    def play_alert(self):
        """
        경고음 재생.
        이미 재생 중이라면 새로 쓰레드를 만들지 않습니다 (오류 방지 핵심).
        """
        if self.is_playing:
            print("[Speaker] 이미 경고음이 울리고 있습니다.")
            return

        self.stop_signal = False
        threading.Thread(target=self._beep, daemon=True).start()

    def stop_alert(self):
        """소리 즉시 중단"""
        if self.is_playing:
            print("[Speaker] 경고음 중단 요청")
            self.stop_signal = True

    def _beep(self):
        self.is_playing = True
        try:
            # 880Hz 삐- 소리 생성
            fs = 44100
            duration = 0.5
            t = np.linspace(0, duration, int(fs * duration), endpoint=False)
            wave = 0.5 * np.sin(2 * np.pi * 880 * t)

            # 멈춤 신호가 올 때까지 무한 반복 (또는 횟수 제한)
            # 비상상황이 해제될 때까지 계속 울리게 하려면 while True 추천
            while not self.stop_signal:
                sd.play(wave, fs)
                sd.wait()
                time.sleep(0.2) # 삐- 삐- 간격

        except Exception as e:
            print(f"[Speaker] 재생 오류: {e}")
        finally:
            self.is_playing = False
            self.stop_signal = False

#===============================================================================================
#2. src/states.py (비상상황 진입 시 소리 울림 추가)
# src/states.py (필요한 부분만 수정)

# ... (앞부분 생략)

class AlertState(State):
    """
    [Alert] 1단계: 낙상 감지 후 잠시 대기
    """
    def on_enter(self):
        print(">> [ALERT] 낙상 감지! 응답 대기 중...")
        # 1. 경고음 시작
        self.context.speaker.play_alert()

    def handle_event(self, event):
        if event == "BUTTON_PRESSED":
            # 버튼 누르면 소리 끄고 정상화
            self.context.speaker.stop_alert()
            self.context.change_state(HomeState, "사용자 버튼 응답")

        elif event == "KEYWORD_DETECTED":
            self.context.change_state(EmergencyState, "비상 키워드")

    def update(self):
        # 20초 지나면 Emergency로 넘어감 (소리는 계속 켜진 상태 유지)
        if time.time() - self.start_time > config.ALERT_TIMEOUT:
            self.context.change_state(EmergencyState, "버튼 미응답")


class EmergencyState(State):
    """
    [Emergency] 2단계: 진짜 비상 상황
    """
    def on_enter(self):
        print(">> [EMERGENCY] 비상 상황 발생! 보호자 알림 전송!")

        # [중요] Alert에서 넘어왔으면 이미 울리고 있겠지만,
        # 혹시 모르니 여기서도 재생 명령을 내립니다.
        # (Hardware 쪽에서 중복 방지 처리를 했으므로 안전합니다)
        self.context.speaker.play_alert()

        self.context.notify_all("비상 상황 발생! 즉시 확인 바랍니다.")

    def handle_event(self, event):
        if event == "BUTTON_PRESSED":
            print("[EMERGENCY] 상황 해제 버튼 눌림")
            # 1. 소리 끄기
            self.context.speaker.stop_alert()
            # 2. 홈으로 복귀
            self.context.change_state(HomeState, "비상 해제 (버튼)")

    def update(self):
        pass

#===============================================================================================

# config.py

import os

# --- 경로 설정 ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
MODEL_DIR = os.path.join(BASE_DIR, 'models')
MOVENET_MODEL_PATH = os.path.join(MODEL_DIR, "movenet_singlepose_lightning.tflite")
AUDIO_MODEL_PATH = os.path.join(MODEL_DIR, "keyword_audio.tflite")

# --- 하드웨어 설정 (RPi 5) ---
BUTTON_PIN = 17     # BCM 17번 핀
GPIO_CHIP = 'gpiochip4' # [수정됨] RPi 5는 보통 gpiochip4를 사용

# --- 타이머 설정 (현재: 테스트 모드) ---
# ※ 실제 사용 시에는 주석에 적힌 시간(초)으로 변경하세요.
PERSON_TIMEOUT = 10     # (테스트용: 10초) / 실제 권장: 1800 (30분)
ALERT_TIMEOUT = 20      # (테스트용: 20초) / 실제 권장: 20
AWAY_TIMEOUT = 30       # [수정됨] (테스트용: 30초) / 실제 권장: 86400 (24시간)
WATCHDOG_TIMEOUT = 60   # 시스템 응답 대기 시간

# --- IFTTT 설정 (보안) ---
# [주의] 이 키는 외부에 노출되지 않도록 조심하세요!
IFTTT_KEY = "fFU6ajuPMx2bI1RigLIYudKy4YqVnP3Eje6C0ypibv8"
IFTTT_WEBHOOK_URL = "https://maker.ifttt.com"

# --- MoveNet 모델 파라미터 ---
MOVENET_INPUT_SIZE = 192
MOVENET_CONFIDENCE_THRESHOLD = 0.3

# --- 낙상 감지 파라미터 ---
FALL_DETECTION_THRESHOLD = 0.5
FRAME_BUFFER_SIZE = 30
ASPECT_RATIO_LOW = 0.3
ASPECT_RATIO_HIGH = 0.5
HEAD_POSITION_THRESHOLD = -0.3 # 머리가 골반보다 꽤 아래에 있어야 함 (음수 값 확인)

# --- 오디오 모델 파라미터 ---
AUDIO_ENABLED = False
KEYWORD_INDEX = 0
AUDIO_CONFIDENCE_THRESHOLD = 0.6


#수정된 src/states.py
# src/states.py
import time
from abc import ABC, abstractmethod
from typing import List
from src.interfaces import INotifier
import config

# --- Abstract State ---
class State(ABC):
    """
    상태 머신의 기본 추상 클래스.
    """
    def __init__(self, context):
        self.context = context
        self.start_time = time.time()

    @abstractmethod
    def on_enter(self):
        pass

    @abstractmethod
    def handle_event(self, event):
        pass

    @abstractmethod
    def update(self):
        pass


# --- Context (State Manager) ---
class Context:
    """
    상태 머신 컨텍스트.
    """
    def __init__(self, speaker, notifiers: List[INotifier]):
        self.speaker = speaker
        self.notifiers = notifiers

        self.last_person_time = time.time()
        self.last_heartbeat = time.time()

        # 초기 상태 설정
        self.state = HomeState(self)
        self.state.on_enter()

    def change_state(self, new_state_cls, reason=""):
        """상태 전환 메서드"""
        print(f"[State] 전환: {self.state.__class__.__name__} -> {new_state_cls.__name__} ({reason})")
        self.state = new_state_cls(self)
        self.state.on_enter()

    def notify_all(self, message):
        for notifier in self.notifiers:
            notifier.send(message)

    def process_event(self, event):
        # [로직] Watchdog 처리
        if event == "HEARTBEAT":
            self.last_heartbeat = time.time()
            return

        # [로직] 현재 상태에게 이벤트 처리 위임
        self.state.handle_event(event)

    def tick(self):
        # [로직] 현재 상태의 주기적 업데이트
        self.state.update()

        # [안정성] Watchdog: AI 시스템 응답 검사
        if time.time() - self.last_heartbeat > config.WATCHDOG_TIMEOUT:
            if not isinstance(self.state, EmergencyState):
                self.change_state(EmergencyState, "AI 시스템 응답 없음")


# --- Concrete States ---

class HomeState(State):
    """
    [Home] 정상 모니터링 상태.
    """
    def on_enter(self):
        print(">> [HOME] 모니터링 중...")

    def handle_event(self, event):
        if event == "PERSON_DETECTED":
            self.context.last_person_time = time.time()
        elif event == "FALL_DETECTED":
            self.context.change_state(AlertState, "낙상 감지")
        elif event == "KEYWORD_DETECTED":
            self.context.change_state(EmergencyState, "비상 키워드 감지")

    def update(self):
        # 장시간 사람 미감지 시 Away로 전환
        if time.time() - self.context.last_person_time > config.PERSON_TIMEOUT:
            self.context.change_state(AwayState, "장시간 미감지")


class AlertState(State):
    """
    [Alert] 낙상 감지 후 사용자 응답 대기 상태.
    """
    def on_enter(self):
        print(">> [ALERT] 응답 대기 중... (경고음 시작)")
        # [중요] 경고음 켜기
        self.context.speaker.play_alert()
        self.context.notify_all("낙상이 감지되었습니다. 괜찮으시면 버튼을 눌러주세요.")

    def handle_event(self, event):
        if event == "BUTTON_PRESSED":
            # [수정됨] 버튼 누르면 소리를 끄고 홈으로 복귀
            self.context.speaker.stop_alert()
            self.context.change_state(HomeState, "사용자 버튼 응답")

        elif event == "KEYWORD_DETECTED":
            self.context.change_state(EmergencyState, "비상 키워드")

    def update(self):
        # 시간 내 미응답 시 Emergency로 전환
        if time.time() - self.start_time > config.ALERT_TIMEOUT:
            self.context.change_state(EmergencyState, "버튼 미응답")


class AwayState(State):
    """
    [Away] 외출 모드.
    """
    def on_enter(self):
        print(">> [AWAY] 외출 모드")

    def handle_event(self, event):
        if event == "PERSON_DETECTED":
            self.context.change_state(HomeState, "사람 감지 (복귀)")

    def update(self):
        if time.time() - self.start_time > config.AWAY_TIMEOUT:
            self.context.change_state(EmergencyState, "장기 외출 미복귀")


class EmergencyState(State):
    """
    [Emergency] 비상 상황 상태.
    """
    def on_enter(self):
        print(">> [EMERGENCY] 비상 상황 발생!")

        # [수정됨] Alert에서 넘어왔더라도 확실하게 소리를 켭니다.
        # (Hardware 쪽에서 중복 방지 처리가 되어있어 안전합니다)
        self.context.speaker.play_alert()

        self.context.notify_all("비상 상황 발생! 즉시 확인 바랍니다.")

    def handle_event(self, event):
        if event == "BUTTON_PRESSED":
            print("[Emergency] 상황 해제 버튼 눌림")
            # [수정됨] 소리를 끄고 홈으로 복귀
            self.context.speaker.stop_alert()
            self.context.change_state(HomeState, "비상 해제 (버튼)")

    def update(self):
        pass
    AlertState (낙상 감지 직후):

#BUTTON_PRESSED 이벤트 발생 시 self.context.speaker.stop_alert()를 추가했습니다.

#이제 버튼을 누르면 "삐-" 소리가 즉시 멈춥니다.

#EmergencyState (진짜 비상 상황):

#on_enter에 play_alert()를 추가했습니다. (소리가 끊기지 않고 확실히 울리도록 보장)

#BUTTON_PRESSED에 역시 stop_alert()를 추가했습니다. 보호자가 와서 버튼을 누르면 소리가 멈춥니다.


#===============================================================================================
#src/processors.py
# src/processors.py
import multiprocessing
import cv2
import numpy as np
import time
import os
import config

try:
    from tflite_runtime.interpreter import Interpreter
except ImportError:
    from tensorflow.lite.python.interpreter import Interpreter

class VideoProcessor(multiprocessing.Process):
    def __init__(self, event_queue):
        super().__init__()
        self.event_queue = event_queue
        self.running = True
        self.model_path = config.MOVENET_MODEL_PATH

    def run(self):
        print("[Video] 프로세스 시작")

        # 1. TFLite 모델 로드
        if not os.path.exists(self.model_path):
            print(f"[Video] 오류: 모델 파일이 없습니다 -> {self.model_path}")
            return

        interpreter = Interpreter(model_path=self.model_path)
        interpreter.allocate_tensors()

        input_details = interpreter.get_input_details()
        output_details = interpreter.get_output_details()

        # MoveNet 입력 크기 (192x192)
        input_size = config.MOVENET_INPUT_SIZE

        # 2. 카메라 열기
        cap = cv2.VideoCapture(0) # 0번 카메라
        if not cap.isOpened():
            print("[Video] 카메라를 열 수 없습니다.")
            return

        print("[Video] 감시 시작...")

        # 낙상 판단을 위한 버퍼 (순간적인 오작동 방지)
        fall_frame_count = 0

        while self.running:
            ret, frame = cap.read()
            if not ret:
                time.sleep(0.1)
                continue

            # 3. 전처리 (Resize & Padding)
            # MoveNet은 192x192 정사각형 입력을 원함
            img = frame.copy()
            img = cv2.resize(img, (input_size, input_size))
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

            # 입력 데이터 형변환 (uint8 또는 float32)
            input_data = np.expand_dims(img, axis=0)
            if input_details[0]['dtype'] == np.float32:
                input_data = (input_data.astype(np.float32) / 255.0) # float 모델인 경우
            else:
                input_data = input_data.astype(np.uint8) # int8 모델인 경우

            # 4. 추론 (Inference)
            interpreter.set_tensor(input_details[0]['index'], input_data)
            interpreter.invoke()

            # 출력: [1, 1, 17, 3] -> (y, x, score)
            keypoints_with_scores = interpreter.get_tensor(output_details[0]['index'])
            keypoints = keypoints_with_scores[0][0] # 17개 관절 데이터

            # 5. 낙상 감지 로직 (좌표 계산)
            if self._detect_fall(keypoints):
                fall_frame_count += 1
                # 연속 5프레임 이상 낙상 자세면 진짜 낙상으로 인정
                if fall_frame_count >= 5:
                    print("[Video] !!! 낙상 감지됨 !!!")
                    self.event_queue.put("FALL_DETECTED")
                    fall_frame_count = 0 # 중복 전송 방지용 리셋 또는 쿨타임 필요
                    time.sleep(2) # 2초 대기
            else:
                fall_frame_count = 0

            # 사람 감지 신호 (관절 신뢰도가 높으면)
            if self._is_person_detected(keypoints):
                 # 너무 자주 보내지 않게 조절 필요하지만 일단 단순화
                 pass
                 # self.event_queue.put("PERSON_DETECTED")

            # CPU 과부하 방지
            time.sleep(0.03)

        cap.release()
        print("[Video] 프로세스 종료")

    def _detect_fall(self, keypoints):
        """
        MoveNet 17개 키포인트로 낙상 판별
        키포인트 인덱스: 0:코, 5,6:어깨, 11,12:골반, 15,16:발목
        """
        # y좌표는 위가 0, 아래가 1
        nose_y = keypoints[0][0]
        left_shoulder_y = keypoints[5][0]
        right_shoulder_y = keypoints[6][0]
        left_hip_y = keypoints[11][0]
        right_hip_y = keypoints[12][0]

        # 신뢰도 확인 (사람이 제대로 찍혔는지)
        confidence = keypoints[0][2] # 코의 정확도
        if confidence < config.MOVENET_CONFIDENCE_THRESHOLD:
            return False

        # [로직 1] 머리 높이 vs 골반 높이 비교
        # 정상: 머리(0.2) < 골반(0.6) (값이 작을수록 위쪽)
        # 낙상: 머리가 골반보다 낮거나(값이 큼) 거의 비슷함

        # 어깨 중간 높이
        shoulder_y = (left_shoulder_y + right_shoulder_y) / 2
        # 골반 중간 높이
        hip_y = (left_hip_y + right_hip_y) / 2

        # config.HEAD_POSITION_THRESHOLD 이용 (예: 0.0)
        # 머리가 골반보다 아래(값으로 치면 더 큼)에 있거나, 거의 수평일 때
        # 일반적인 서 있는 자세: Nose < Shoulder < Hip
        # 누운 자세: Nose ≈ Shoulder ≈ Hip

        # 간단한 알고리즘: 머리가 엉덩이보다 "낮게(y값이 크게)" 위치하면 낙상
        if nose_y > hip_y:
            return True

        return False

    def _is_person_detected(self, keypoints):
        # 평균 신뢰도가 기준치 이상이면 사람으로 간주
        scores = keypoints[:, 2]
        avg_score = np.mean(scores)
        return avg_score > config.MOVENET_CONFIDENCE_THRESHOLD

    def terminate(self):
        self.running = False
        super().terminate()

class AudioProcessor(multiprocessing.Process):
    """
    (임시) 오디오 프로세서는 비워둡니다. 나중에 추가하세요.
    """
    def __init__(self, event_queue):
        super().__init__()
        self.event_queue = event_queue
        self.running = True

    def run(self):
        print("[Audio] (대기중) 오디오 감시 시작")
        while self.running:
            time.sleep(1)

#===============================================================================================

# src/hardware.py
import threading
import time
import numpy as np
import sounddevice as sd
from multiprocessing import Queue
from gpiozero import Button  # RPi 5 추천 라이브러리
import config

class ButtonReader:
    """
    [RPi 5 권장] gpiozero 라이브러리를 사용하여 버튼 입력 감지.
    복잡한 Chip 설정 없이 자동으로 핀을 찾아줍니다.
    """
    def __init__(self, event_queue: Queue):
        self.queue = event_queue
        self.pin = config.BUTTON_PIN
        self.btn = None

        try:
            # pull_up=True: 내부 저항 사용
            # bounce_time=0.2: 버튼 한번 눌렀는데 여러번 찍히는 것 방지
            self.btn = Button(self.pin, pull_up=True, bounce_time=0.2)

            # 이벤트 핸들러 등록
            self.btn.when_pressed = self._on_press
            print(f"[Hardware] 버튼 초기화 완료 (Pin {self.pin} / gpiozero)")

        except Exception as e:
            print(f"[Hardware] 버튼 초기화 실패: {e}")
            # gpiozero가 없거나 핀 설정 오류 시

    def start(self):
        """gpiozero는 별도 루프 없이 백그라운드에서 감시하므로 빈 함수 유지"""
        pass

    def _on_press(self):
        """버튼이 눌렸을 때 실행되는 함수"""
        print("[Hardware] 버튼 눌림 감지!")
        self.queue.put("BUTTON_PRESSED")

    def cleanup(self):
        """자원 해제"""
        if self.btn:
            self.btn.close()
        print("[Hardware] 버튼 자원 해제")


class Speaker:
    """
    RPi 5 오디오 출력 (SoundDevice 사용).
    중복 재생 방지 및 강제 종료 기능 포함.
    """
    def __init__(self):
        self.is_playing = False
        self.stop_signal = False

    def play_alert(self):
        """
        경고음 재생 (비동기 스레드).
        이미 울리고 있으면 무시합니다 (중복 방지).
        """
        if self.is_playing:
            return  # 이미 재생 중이면 무시

        self.stop_signal = False
        threading.Thread(target=self._beep, daemon=True).start()

    def stop_alert(self):
        """
        소리를 즉시 멈춥니다.
        (버튼을 눌렀을 때 호출됨)
        """
        if self.is_playing:
            print("[Speaker] 경고음 중단 요청")
            self.stop_signal = True

    def _beep(self):
        """실제 사운드 재생 로직"""
        self.is_playing = True
        try:
            fs = 44100
            duration = 0.5
            # 880Hz 사인파 생성
            t = np.linspace(0, duration, int(fs * duration), endpoint=False)
            wave = 0.5 * np.sin(2 * np.pi * 880 * t)

            # 멈춤 신호가 오기 전까지 반복 (또는 횟수 제한)
            # 여기서는 20회 반복으로 설정 (약 15초)
            for i in range(20):
                if self.stop_signal:
                    break

                try:
                    sd.play(wave, fs)
                    sd.wait()
                    time.sleep(0.2)
                except Exception as e:
                    print(f"[Hardware] 오디오 출력 오류: {e}")
                    break

        except Exception as e:
            print(f"[Hardware] 스피커 오류: {e}")
        finally:
            self.is_playing = False
            self.stop_signal = False
#변경된 점 요약
#gpiod 삭제 -> gpiozero 적용: 코드가 훨씬 간결해지고 RPi 5에서 핀을 못 찾는 오류가 해결됩니다.

#Speaker.stop_alert() 추가: 이제 버튼을 누르면 stop_signal이 True가 되어 소리가 바로 멈춥니다.

#중복 재생 방지: if self.is_playing: return 코드를 넣어 소리가 겹쳐서 나는 오류를 막았습니다.


#===============================================================================================